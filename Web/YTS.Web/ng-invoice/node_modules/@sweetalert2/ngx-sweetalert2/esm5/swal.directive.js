/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
import { ComponentFactoryResolver, Directive, EventEmitter, HostListener, Input, Output, ViewContainerRef } from '@angular/core';
import Swal from 'sweetalert2';
import { SwalComponent } from './swal.component';
/**
 * [swal] directive. It takes a value that defines the Sweet Alert and can be of three types:
 *
 * 1) A simple array of two or three strings defining [title, text, type] - the type being optional, ex:
 *
 *    <button [swal]="['Title', 'Text']">Click me</button>
 *
 * 2) A native SweetAlert2 options object, ex:
 *
 *    <button [swal]="{ title: 'Title', text: 'Text' }">Click me</button>
 *
 * 3) A reference to an existing SwalComponent instance for more advanced uses, ex:
 *
 *    <button [swal]="mySwal">Click me</button>
 *    <swal #mySwal title="Title" text="Text"></swal>
 */
var SwalDirective = /** @class */ (function () {
    function SwalDirective(viewContainerRef, resolver) {
        this.viewContainerRef = viewContainerRef;
        this.resolver = resolver;
        /**
         * Emits when the user clicks "Confirm".
         * Bears a value when using "input", resolved "preConfirm", etc.
         *
         * Example:
         *     public handleConfirm(email: string): void {
         *         // ... save user email
         *     }
         */
        this.confirm = new EventEmitter();
        /**
         * Emits when the user clicks "Cancel" (or dismisses the modal by any other way).
         * By default, it will emit a string representing the reason for which the SweetAlert has been closed, or the
         * value of a rejected "preConfirm".
         *
         * Example:
         *     public handleCancel(reason: string): void {
         *         // reason can be 'cancel', 'overlay', 'close', and 'timer'
         *         // ... do something
         *     }
         */
        this.cancel = new EventEmitter();
    }
    Object.defineProperty(SwalDirective.prototype, "swal", {
        /**
         * SweetAlert2 options or a SwalComponent instance.
         * See the class doc block for more informations.
         */
        set: /**
         * SweetAlert2 options or a SwalComponent instance.
         * See the class doc block for more informations.
         * @param {?} options
         * @return {?}
         */
        function (options) {
            if (options instanceof SwalComponent) {
                this.swalInstance = options;
            }
            else if (Array.isArray(options)) {
                this.swalOptions = Swal.argsToParams(options);
            }
            else {
                this.swalOptions = options;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * OnInit lifecycle handler.
     * Creates a SwalComponent instance if the user didn't provided one and binds on that component (confirm) and
     * (cancel) outputs to reemit on the directive.
     */
    /**
     * OnInit lifecycle handler.
     * Creates a SwalComponent instance if the user didn't provided one and binds on that component (confirm) and
     * (cancel) outputs to reemit on the directive.
     * @return {?}
     */
    SwalDirective.prototype.ngOnInit = /**
     * OnInit lifecycle handler.
     * Creates a SwalComponent instance if the user didn't provided one and binds on that component (confirm) and
     * (cancel) outputs to reemit on the directive.
     * @return {?}
     */
    function () {
        if (!this.swalInstance) {
            /** @type {?} */
            var factory = this.resolver.resolveComponentFactory(SwalComponent);
            this.swalRef = this.viewContainerRef.createComponent(factory);
            this.swalInstance = this.swalRef.instance;
        }
    };
    /**
     * OnDestroy lifecycle handler.
     * Destroys the dynamically-created SwalComponent and unsubscribes from that component's (confirm) and (cancel).
     */
    /**
     * OnDestroy lifecycle handler.
     * Destroys the dynamically-created SwalComponent and unsubscribes from that component's (confirm) and (cancel).
     * @return {?}
     */
    SwalDirective.prototype.ngOnDestroy = /**
     * OnDestroy lifecycle handler.
     * Destroys the dynamically-created SwalComponent and unsubscribes from that component's (confirm) and (cancel).
     * @return {?}
     */
    function () {
        if (this.swalRef) {
            this.swalRef.destroy();
        }
    };
    /**
     * Click handler.
     * The directive listens for onclick events on its host element.
     * When this happens, it shows the <swal> attached to this directive.
     */
    /**
     * Click handler.
     * The directive listens for onclick events on its host element.
     * When this happens, it shows the <swal> attached to this directive.
     * @param {?} event
     * @return {?}
     */
    SwalDirective.prototype.onHostClicked = /**
     * Click handler.
     * The directive listens for onclick events on its host element.
     * When this happens, it shows the <swal> attached to this directive.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        event.preventDefault();
        event.stopImmediatePropagation();
        event.stopPropagation();
        if (this.swalOptions) {
            this.swalInstance.options = this.swalOptions;
        }
        /** @type {?} */
        var confirmSub = this.swalInstance.confirm.asObservable().subscribe(function (v) { return _this.confirm.emit(v); });
        /** @type {?} */
        var cancelSub = this.swalInstance.cancel.asObservable().subscribe(function (v) { return _this.cancel.emit(v); });
        this.swalInstance.show().then(unsubscribe);
        /**
         * @return {?}
         */
        function unsubscribe() {
            confirmSub.unsubscribe();
            cancelSub.unsubscribe();
        }
    };
    SwalDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[swal]'
                },] }
    ];
    /** @nocollapse */
    SwalDirective.ctorParameters = function () { return [
        { type: ViewContainerRef },
        { type: ComponentFactoryResolver }
    ]; };
    SwalDirective.propDecorators = {
        swal: [{ type: Input }],
        confirm: [{ type: Output }],
        cancel: [{ type: Output }],
        onHostClicked: [{ type: HostListener, args: ['click', ['$event'],] }]
    };
    return SwalDirective;
}());
export { SwalDirective };
if (false) {
    /**
     * Emits when the user clicks "Confirm".
     * Bears a value when using "input", resolved "preConfirm", etc.
     *
     * Example:
     *     public handleConfirm(email: string): void {
     *         // ... save user email
     *     }
     * @type {?}
     */
    SwalDirective.prototype.confirm;
    /**
     * Emits when the user clicks "Cancel" (or dismisses the modal by any other way).
     * By default, it will emit a string representing the reason for which the SweetAlert has been closed, or the
     * value of a rejected "preConfirm".
     *
     * Example:
     *     public handleCancel(reason: string): void {
     *         // reason can be 'cancel', 'overlay', 'close', and 'timer'
     *         // ... do something
     *     }
     * @type {?}
     */
    SwalDirective.prototype.cancel;
    /**
     * When the user does not provides a SwalComponent instance, we create it on-the-fly and assign the plain-object
     * options to it.
     * This fields keeps a reference to the dynamically-created <swal>, to destroy it along this directive instance.
     * @type {?}
     */
    SwalDirective.prototype.swalRef;
    /**
     * An instance of the <swal> component that this directive controls.
     * Could be an instance passed by the user, otherwise it's the instance we've dynamically created.
     * @type {?}
     */
    SwalDirective.prototype.swalInstance;
    /**
     * Holds the native SweetAlert2 options.
     * Empty when the user passed an existing SwalComponent instance.
     * @type {?}
     */
    SwalDirective.prototype.swalOptions;
    /** @type {?} */
    SwalDirective.prototype.viewContainerRef;
    /** @type {?} */
    SwalDirective.prototype.resolver;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3dhbC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Ac3dlZXRhbGVydDIvbmd4LXN3ZWV0YWxlcnQyLyIsInNvdXJjZXMiOlsic3dhbC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFDSCx3QkFBd0IsRUFBZ0IsU0FBUyxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFxQixNQUFNLEVBQy9HLGdCQUFnQixFQUNuQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLElBQW1ELE1BQU0sYUFBYSxDQUFDO0FBQzlFLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQmpEO0lBNkRJLHVCQUNxQixnQkFBa0MsRUFDbEMsUUFBa0M7UUFEbEMscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFrQjtRQUNsQyxhQUFRLEdBQVIsUUFBUSxDQUEwQjs7Ozs7Ozs7OztRQXBDN0IsWUFBTyxHQUFHLElBQUksWUFBWSxFQUFPLENBQUM7Ozs7Ozs7Ozs7OztRQWFsQyxXQUFNLEdBQUcsSUFBSSxZQUFZLEVBQU8sQ0FBQztJQXdCM0QsQ0FBQztJQXhERCxzQkFBb0IsK0JBQUk7UUFKeEI7OztXQUdHOzs7Ozs7O1FBQ0gsVUFBeUIsT0FBbUU7WUFDeEYsSUFBSSxPQUFPLFlBQVksYUFBYSxFQUFFO2dCQUNsQyxJQUFJLENBQUMsWUFBWSxHQUFHLE9BQU8sQ0FBQzthQUMvQjtpQkFBTSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUU7Z0JBQy9CLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQzthQUNqRDtpQkFBTTtnQkFDSCxJQUFJLENBQUMsV0FBVyxHQUFHLE9BQU8sQ0FBQzthQUM5QjtRQUNMLENBQUM7OztPQUFBO0lBa0REOzs7O09BSUc7Ozs7Ozs7SUFDSSxnQ0FBUTs7Ozs7O0lBQWY7UUFDSSxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRTs7Z0JBQ2QsT0FBTyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsdUJBQXVCLENBQUMsYUFBYSxDQUFDO1lBRXBFLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUM5RCxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDO1NBQzdDO0lBQ0wsQ0FBQztJQUVEOzs7T0FHRzs7Ozs7O0lBQ0ksbUNBQVc7Ozs7O0lBQWxCO1FBQ0ksSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ2QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQztTQUMxQjtJQUNMLENBQUM7SUFFRDs7OztPQUlHOzs7Ozs7OztJQUVJLHFDQUFhOzs7Ozs7O0lBRHBCLFVBQ3FCLEtBQWlCO1FBRHRDLGlCQW1CQztRQWpCRyxLQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDdkIsS0FBSyxDQUFDLHdCQUF3QixFQUFFLENBQUM7UUFDakMsS0FBSyxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBRXhCLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUNsQixJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO1NBQ2hEOztZQUVLLFVBQVUsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUUsQ0FBQyxTQUFTLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxLQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBcEIsQ0FBb0IsQ0FBQzs7WUFDMUYsU0FBUyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDLFNBQVMsQ0FBQyxVQUFBLENBQUMsSUFBSSxPQUFBLEtBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFuQixDQUFtQixDQUFDO1FBRTdGLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDOzs7O1FBRTNDLFNBQVMsV0FBVztZQUNoQixVQUFVLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDekIsU0FBUyxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQzVCLENBQUM7SUFDTCxDQUFDOztnQkFsSEosU0FBUyxTQUFDO29CQUNQLFFBQVEsRUFBRSxRQUFRO2lCQUNyQjs7OztnQkF2QkcsZ0JBQWdCO2dCQURoQix3QkFBd0I7Ozt1QkE4QnZCLEtBQUs7MEJBbUJMLE1BQU07eUJBYU4sTUFBTTtnQ0F1RE4sWUFBWSxTQUFDLE9BQU8sRUFBRSxDQUFDLFFBQVEsQ0FBQzs7SUFvQnJDLG9CQUFDO0NBQUEsQUFuSEQsSUFtSEM7U0FoSFksYUFBYTs7Ozs7Ozs7Ozs7O0lBd0J0QixnQ0FBNEQ7Ozs7Ozs7Ozs7Ozs7SUFhNUQsK0JBQTJEOzs7Ozs7O0lBTzNELGdDQUE2Qzs7Ozs7O0lBTTdDLHFDQUFvQzs7Ozs7O0lBTXBDLG9DQUF1Qzs7SUFHbkMseUNBQW1EOztJQUNuRCxpQ0FBbUQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgQ29tcG9uZW50UmVmLCBEaXJlY3RpdmUsIEV2ZW50RW1pdHRlciwgSG9zdExpc3RlbmVyLCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXQsIE91dHB1dCxcbiAgICBWaWV3Q29udGFpbmVyUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IFN3YWwsIHsgU3dlZXRBbGVydEFycmF5T3B0aW9ucywgU3dlZXRBbGVydE9wdGlvbnMgfSBmcm9tICdzd2VldGFsZXJ0Mic7XG5pbXBvcnQgeyBTd2FsQ29tcG9uZW50IH0gZnJvbSAnLi9zd2FsLmNvbXBvbmVudCc7XG5cbi8qKlxuICogW3N3YWxdIGRpcmVjdGl2ZS4gSXQgdGFrZXMgYSB2YWx1ZSB0aGF0IGRlZmluZXMgdGhlIFN3ZWV0IEFsZXJ0IGFuZCBjYW4gYmUgb2YgdGhyZWUgdHlwZXM6XG4gKlxuICogMSkgQSBzaW1wbGUgYXJyYXkgb2YgdHdvIG9yIHRocmVlIHN0cmluZ3MgZGVmaW5pbmcgW3RpdGxlLCB0ZXh0LCB0eXBlXSAtIHRoZSB0eXBlIGJlaW5nIG9wdGlvbmFsLCBleDpcbiAqXG4gKiAgICA8YnV0dG9uIFtzd2FsXT1cIlsnVGl0bGUnLCAnVGV4dCddXCI+Q2xpY2sgbWU8L2J1dHRvbj5cbiAqXG4gKiAyKSBBIG5hdGl2ZSBTd2VldEFsZXJ0MiBvcHRpb25zIG9iamVjdCwgZXg6XG4gKlxuICogICAgPGJ1dHRvbiBbc3dhbF09XCJ7IHRpdGxlOiAnVGl0bGUnLCB0ZXh0OiAnVGV4dCcgfVwiPkNsaWNrIG1lPC9idXR0b24+XG4gKlxuICogMykgQSByZWZlcmVuY2UgdG8gYW4gZXhpc3RpbmcgU3dhbENvbXBvbmVudCBpbnN0YW5jZSBmb3IgbW9yZSBhZHZhbmNlZCB1c2VzLCBleDpcbiAqXG4gKiAgICA8YnV0dG9uIFtzd2FsXT1cIm15U3dhbFwiPkNsaWNrIG1lPC9idXR0b24+XG4gKiAgICA8c3dhbCAjbXlTd2FsIHRpdGxlPVwiVGl0bGVcIiB0ZXh0PVwiVGV4dFwiPjwvc3dhbD5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbc3dhbF0nXG59KVxuZXhwb3J0IGNsYXNzIFN3YWxEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gICAgLyoqXG4gICAgICogU3dlZXRBbGVydDIgb3B0aW9ucyBvciBhIFN3YWxDb21wb25lbnQgaW5zdGFuY2UuXG4gICAgICogU2VlIHRoZSBjbGFzcyBkb2MgYmxvY2sgZm9yIG1vcmUgaW5mb3JtYXRpb25zLlxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBzZXQgc3dhbChvcHRpb25zOiBTd2FsQ29tcG9uZW50IHwgU3dlZXRBbGVydE9wdGlvbnMgfCBTd2VldEFsZXJ0QXJyYXlPcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zIGluc3RhbmNlb2YgU3dhbENvbXBvbmVudCkge1xuICAgICAgICAgICAgdGhpcy5zd2FsSW5zdGFuY2UgPSBvcHRpb25zO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgICAgIHRoaXMuc3dhbE9wdGlvbnMgPSBTd2FsLmFyZ3NUb1BhcmFtcyhvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3dhbE9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW1pdHMgd2hlbiB0aGUgdXNlciBjbGlja3MgXCJDb25maXJtXCIuXG4gICAgICogQmVhcnMgYSB2YWx1ZSB3aGVuIHVzaW5nIFwiaW5wdXRcIiwgcmVzb2x2ZWQgXCJwcmVDb25maXJtXCIsIGV0Yy5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICogICAgIHB1YmxpYyBoYW5kbGVDb25maXJtKGVtYWlsOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgKiAgICAgICAgIC8vIC4uLiBzYXZlIHVzZXIgZW1haWxcbiAgICAgKiAgICAgfVxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBwdWJsaWMgcmVhZG9ubHkgY29uZmlybSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgd2hlbiB0aGUgdXNlciBjbGlja3MgXCJDYW5jZWxcIiAob3IgZGlzbWlzc2VzIHRoZSBtb2RhbCBieSBhbnkgb3RoZXIgd2F5KS5cbiAgICAgKiBCeSBkZWZhdWx0LCBpdCB3aWxsIGVtaXQgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSByZWFzb24gZm9yIHdoaWNoIHRoZSBTd2VldEFsZXJ0IGhhcyBiZWVuIGNsb3NlZCwgb3IgdGhlXG4gICAgICogdmFsdWUgb2YgYSByZWplY3RlZCBcInByZUNvbmZpcm1cIi5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICogICAgIHB1YmxpYyBoYW5kbGVDYW5jZWwocmVhc29uOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgKiAgICAgICAgIC8vIHJlYXNvbiBjYW4gYmUgJ2NhbmNlbCcsICdvdmVybGF5JywgJ2Nsb3NlJywgYW5kICd0aW1lcidcbiAgICAgKiAgICAgICAgIC8vIC4uLiBkbyBzb21ldGhpbmdcbiAgICAgKiAgICAgfVxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBwdWJsaWMgcmVhZG9ubHkgY2FuY2VsID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSB1c2VyIGRvZXMgbm90IHByb3ZpZGVzIGEgU3dhbENvbXBvbmVudCBpbnN0YW5jZSwgd2UgY3JlYXRlIGl0IG9uLXRoZS1mbHkgYW5kIGFzc2lnbiB0aGUgcGxhaW4tb2JqZWN0XG4gICAgICogb3B0aW9ucyB0byBpdC5cbiAgICAgKiBUaGlzIGZpZWxkcyBrZWVwcyBhIHJlZmVyZW5jZSB0byB0aGUgZHluYW1pY2FsbHktY3JlYXRlZCA8c3dhbD4sIHRvIGRlc3Ryb3kgaXQgYWxvbmcgdGhpcyBkaXJlY3RpdmUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgcHJpdmF0ZSBzd2FsUmVmOiBDb21wb25lbnRSZWY8U3dhbENvbXBvbmVudD47XG5cbiAgICAvKipcbiAgICAgKiBBbiBpbnN0YW5jZSBvZiB0aGUgPHN3YWw+IGNvbXBvbmVudCB0aGF0IHRoaXMgZGlyZWN0aXZlIGNvbnRyb2xzLlxuICAgICAqIENvdWxkIGJlIGFuIGluc3RhbmNlIHBhc3NlZCBieSB0aGUgdXNlciwgb3RoZXJ3aXNlIGl0J3MgdGhlIGluc3RhbmNlIHdlJ3ZlIGR5bmFtaWNhbGx5IGNyZWF0ZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBzd2FsSW5zdGFuY2U6IFN3YWxDb21wb25lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBIb2xkcyB0aGUgbmF0aXZlIFN3ZWV0QWxlcnQyIG9wdGlvbnMuXG4gICAgICogRW1wdHkgd2hlbiB0aGUgdXNlciBwYXNzZWQgYW4gZXhpc3RpbmcgU3dhbENvbXBvbmVudCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIHN3YWxPcHRpb25zOiBTd2VldEFsZXJ0T3B0aW9ucztcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSB2aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IHJlc29sdmVyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPbkluaXQgbGlmZWN5Y2xlIGhhbmRsZXIuXG4gICAgICogQ3JlYXRlcyBhIFN3YWxDb21wb25lbnQgaW5zdGFuY2UgaWYgdGhlIHVzZXIgZGlkbid0IHByb3ZpZGVkIG9uZSBhbmQgYmluZHMgb24gdGhhdCBjb21wb25lbnQgKGNvbmZpcm0pIGFuZFxuICAgICAqIChjYW5jZWwpIG91dHB1dHMgdG8gcmVlbWl0IG9uIHRoZSBkaXJlY3RpdmUuXG4gICAgICovXG4gICAgcHVibGljIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuc3dhbEluc3RhbmNlKSB7XG4gICAgICAgICAgICBjb25zdCBmYWN0b3J5ID0gdGhpcy5yZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShTd2FsQ29tcG9uZW50KTtcblxuICAgICAgICAgICAgdGhpcy5zd2FsUmVmID0gdGhpcy52aWV3Q29udGFpbmVyUmVmLmNyZWF0ZUNvbXBvbmVudChmYWN0b3J5KTtcbiAgICAgICAgICAgIHRoaXMuc3dhbEluc3RhbmNlID0gdGhpcy5zd2FsUmVmLmluc3RhbmNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT25EZXN0cm95IGxpZmVjeWNsZSBoYW5kbGVyLlxuICAgICAqIERlc3Ryb3lzIHRoZSBkeW5hbWljYWxseS1jcmVhdGVkIFN3YWxDb21wb25lbnQgYW5kIHVuc3Vic2NyaWJlcyBmcm9tIHRoYXQgY29tcG9uZW50J3MgKGNvbmZpcm0pIGFuZCAoY2FuY2VsKS5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnN3YWxSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuc3dhbFJlZi5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGljayBoYW5kbGVyLlxuICAgICAqIFRoZSBkaXJlY3RpdmUgbGlzdGVucyBmb3Igb25jbGljayBldmVudHMgb24gaXRzIGhvc3QgZWxlbWVudC5cbiAgICAgKiBXaGVuIHRoaXMgaGFwcGVucywgaXQgc2hvd3MgdGhlIDxzd2FsPiBhdHRhY2hlZCB0byB0aGlzIGRpcmVjdGl2ZS5cbiAgICAgKi9cbiAgICBASG9zdExpc3RlbmVyKCdjbGljaycsIFsnJGV2ZW50J10pXG4gICAgcHVibGljIG9uSG9zdENsaWNrZWQoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIGlmICh0aGlzLnN3YWxPcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnN3YWxJbnN0YW5jZS5vcHRpb25zID0gdGhpcy5zd2FsT3B0aW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbmZpcm1TdWIgPSB0aGlzLnN3YWxJbnN0YW5jZS5jb25maXJtLmFzT2JzZXJ2YWJsZSgpLnN1YnNjcmliZSh2ID0+IHRoaXMuY29uZmlybS5lbWl0KHYpKTtcbiAgICAgICAgY29uc3QgY2FuY2VsU3ViID0gdGhpcy5zd2FsSW5zdGFuY2UuY2FuY2VsLmFzT2JzZXJ2YWJsZSgpLnN1YnNjcmliZSh2ID0+IHRoaXMuY2FuY2VsLmVtaXQodikpO1xuXG4gICAgICAgIHRoaXMuc3dhbEluc3RhbmNlLnNob3coKS50aGVuKHVuc3Vic2NyaWJlKTtcblxuICAgICAgICBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgICAgIGNvbmZpcm1TdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIGNhbmNlbFN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuIl19